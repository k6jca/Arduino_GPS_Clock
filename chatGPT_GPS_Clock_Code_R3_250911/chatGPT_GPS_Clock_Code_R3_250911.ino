// chatGPT_GPS_Clock_Code_250905.ino
// 5 September 2025
//
// Almost all code (90% ?) generated by chatGPT, but after a certain point 
// I took over because it would start making errors from one revision to
// the next, such as changing working code to non-working code (e.g. 
// changing which TMS1367 display segments to turn on to represent 
// characters.  I'd told chatGPT the actual segments to turn on for
// each character, and the code was initially generated with these
// segments (e.g. SEG_E | SEG_G to make a small-case 'r').  But in
// a later rev, it changed these values to HEX numbers (unbeknownst 
// to me) which actually represented garbage characters).
//
// Another bug that was frustrating to find involved chatGPT 
// defining and initializing variables *within* a switch statement
// (i.e. within a block of 'case' code), causing the software to
// barf when running.  This error was not flagged as an error by the 
// compiler. I burned alot of time trying to figure out why certain
// blocks of 'case' code weren't operating.  Fortunately, Google's AI 
// identified the problem when I searched for causes of Arduino Case 
// statement errors.
//
// Now, to the code...
//
// There are 6 menu items.  Starting with item 0:
//
// 0:  Clock
// 1:  Time Zone offset from GMT (a negative number, e.g. -8 for PST).
// 2:  Display brightness.  Ranges from 0 to 7, 7 being brightest.
// 3.  Display Time in a 24 or 12 hour format.
// 4.  Enable blinking of the display's colon (located between 
//     hours and minutes).
// 5.  GPS soft-serial port's baud rate.  Options are:
//        9600, 19200, 38400, 57600, or 115.2K baud.
//
// Menu selection is chosen using the MENU button -- depress it, and
// upon its release (i.e. a low-to-high transition), the display will step
// to the next menu item.  After stepping last menu item, the next menu step
// will be back to Menu item 0 (time).
//
//  Within a menu (e.g. Time Zone), choices can be scrolled through using 
//  the NEXT key (the displayed choice will step to next choice upon a 
//  low-to-high transition of nNEXT).
//
//  Stop on the desired choice and then use the menu button to step out of 
//  that menu option.  The choice you selected is now the new value, and
//  NANO EEPROM will be updated with it.  
//
//  Thus, with these variables stored in EEPROM, operating parameters are
//  retained even if power is lost.
//   
//  Regarding the Time display at power up...
//  At powerup the NEO 6M continuously sends time = 0:0:0.  During this
//  period the Display shows dashes.  It is only after the GPS receiver starts
//  sending non-zero values of time that actual time will be displayed on the LEDs.
//
//  Notes:
//  ------
//  1.  External switches and pushbuttons are scanned at a 20 msec rate (for 
//      debouncing).  But the display is only update once a second, so there
//      can be a lag between button switch action and the display changing.
//
// k6jca



#include <TM1637Display.h>
#include <EEPROM.h>
#include <SoftwareSerial.h>
#include <TinyGPSPlus.h>

//# define VERBOSE_SERIAL


// Revisions:
//
// 1 - 250905 -- original code
// 2 - 250909 -- Add menu item to view satellites tracked.
// 3 - 250911 -- 1.  Add analog input to read light-sensitive resistor
//                   for changing brightness vs. ambient light.
//               2.  Change brightness range from 0-7 to 0-3
//               3.  Add menu items:
//                      7 - Enable/Disable Ambient Light Adjust
//                      8 - Display Ambient Light Detector (0-1023)

int Rev = 3;          // Firmware revision


// ---------------- Pin definitions ----------------
const int nMenuPin = 7;        
const int nNextPin = 8;
const int nGMTPin  = 9;
const int nDSTPin  = 10;
const int CLK = 2;
const int DIO = 3;
const int gpsRxPin = 6;
const int gpsTxPin = 11;

const int analogPin = A0;   // Analog input pin


// ---------------- Menu system ----------------
const int numMenuItems   = 9;     // Number of menus
int currentMenuItem      = 0;
int lastMenuItem         = 0;

// ---------------- State tracking ----------------
bool lastMenuState = HIGH; 
bool currentMenuState = HIGH;
bool lastNextState = HIGH;
bool currentNextState = HIGH;
bool nGMT = false;
bool nDST = false;
bool brightnessChanged = false;

// ---------------- Timing ----------------
unsigned long lastSampleTime = 0;
const unsigned long sampleInterval = 20; // 20 ms
unsigned long lastGpsSample = 0;
const unsigned long gpsSampleInterval = 1000; // 1 sec

// ---------------- Brightness Threshods (vs ADC In) ---------
int hiBright   = 775;
int midBright  = 500;
int lowBright  = 300;
int hyst       = 25;   // add some hysterises to brightness switching

// ---------------- Adjustable values ----------------
int  Zone = -8;            // time zone delta, in hours, from GMT
int  absZone = -Zone;
int  maxBrightness = 3;       // display max brightness 
int  Brightness = maxBrightness;
int  minBrightness = 0;
int  rawAnalog = 0;        // Analog Input, referenced to 5V, 1023 max
bool Hour24 = false;
bool blink  = true;        // enable or disable blinking of display's cursor
bool receivingTime = false;// true if receiving valid time from gps
bool ambient = true;       // enable ambient light detector
long gpsBaud = 9600;       // gps baud rate
long baudDisplay = gpsBaud;


uint8_t splash1[4] = {0,0,0,0};
uint8_t splash2[4] = {0,0,0,0};


// ---------------- Time variables ----------------
int delayedHour = 0;
int Time = 0;
int GPSTime = 0;
bool colonState = false;
int gpsHour   = 0;
int gpsMinute = 0;
int gpsSecond = 0;
int sats = 0;         // number of satellites tracked


// ---------------- Display object ----------------
TM1637Display display(CLK, DIO);

// ---------------- SoftwareSerial and GPS ----------------
SoftwareSerial gpsSerial(gpsRxPin, gpsTxPin);
TinyGPSPlus gps;

// ---------------- EEPROM Addresses ----------------
const int EEPROM_ADDR_BRIGHTNESS = 0;
const int EEPROM_ADDR_ZONE       = 1;
const int EEPROM_ADDR_HOUR24     = 2;
const int EEPROM_ADDR_GPSBAUD    = 3;
const int EEPROM_ADDR_BLINK      = 7;
const int EEPROM_ADDR_AMBIENT    = 8;


uint8_t dash[4] = {0x40, 0x40, 0x40, 0x40}; // SEG_G for each digit


// ---------------- Helper functions ----------------
void writeLongToEEPROM(int addr, long value) {
  for (int i = 0; i < 4; i++) {
    EEPROM.update(addr + i, (value >> (8 * i)) & 0xFF);
  }
}

long readLongFromEEPROM(int addr) {
  long value = 0;
  for (int i = 0; i < 4; i++) {
    value |= ((long)EEPROM.read(addr + i)) << (8 * i);
  }
  return value;
}

// ---------------- Setup ----------------
void setup() {
  pinMode(nMenuPin, INPUT_PULLUP);
  pinMode(nNextPin, INPUT_PULLUP);
  pinMode(nGMTPin, INPUT_PULLUP);
  pinMode(nDSTPin, INPUT_PULLUP);

  Serial.begin(115200);
  Serial.println("System Started");

  // Read stored EEPROM values
  int storedBrightness = EEPROM.read(EEPROM_ADDR_BRIGHTNESS);
  if (storedBrightness >= minBrightness && storedBrightness <= 7) Brightness = storedBrightness;
  Serial.print("Stored Brightness: "); Serial.println(Brightness);

  int storedZoneRaw = EEPROM.read(EEPROM_ADDR_ZONE);
  int storedZone = (storedZoneRaw > 127) ? storedZoneRaw - 256 : storedZoneRaw;
  if (storedZone >= -23 && storedZone <= 0) Zone = storedZone;
  Serial.print("Stored Zone: "); Serial.println(Zone);

  Hour24 = EEPROM.read(EEPROM_ADDR_HOUR24) != 0;
  Serial.print("Stored Hour24: "); Serial.println(Hour24 ? "24h" : "12h");

  long storedGpsBaud = readLongFromEEPROM(EEPROM_ADDR_GPSBAUD);
  if (storedGpsBaud == 9600 || storedGpsBaud == 19200 || storedGpsBaud == 38400 ||
      storedGpsBaud == 57600 || storedGpsBaud == 115200) gpsBaud = storedGpsBaud;
  Serial.print("Stored GPS Baud: "); Serial.println(gpsBaud);

  blink = EEPROM.read(EEPROM_ADDR_BLINK) != 0;
  Serial.print("Stored Blink: "); Serial.println(blink ? "true" : "false");

  ambient = EEPROM.read(EEPROM_ADDR_AMBIENT) != 0;
  Serial.print("Stored Ambient Light Enable: "); Serial.println(ambient ? "true" : "false");

  display.setBrightness(Brightness);
  display.clear();

  gpsSerial.begin(gpsBaud);
  Serial.print("GPS SoftwareSerial started at "); Serial.println(gpsBaud);


  // Splash 1 (1 sec)
  splash1[0] = 0x00;
  splash1[1] = SEG_B|SEG_C|SEG_D|SEG_E;             // J
  splash1[2] = SEG_A|SEG_D|SEG_E|SEG_F;             // C
  splash1[3] = SEG_A|SEG_B|SEG_C|SEG_E|SEG_F|SEG_G; // A
  display.setSegments(splash1);
  delay(1200);
  

  // Splash 2 (2 sec) showing revision
  int tens = (Rev % 100) / 10;
  int ones = Rev % 10;
  splash2[0] = 0; 
  splash2[1] = SEG_E|SEG_G | 0x80;       // 'r:'
  splash2[2] = display.encodeDigit(tens);
  splash2[3] = display.encodeDigit(ones);
  display.setSegments(splash2);
  delay(1200);

  // After splash 2, set display to all dashes
  display.setSegments(dash);
}

// ---------------- Main loop ----------------
void loop() {
  unsigned long now = millis();

  // ---------------- Sample buttons every 20ms ----------------
  if (now - lastSampleTime >= sampleInterval) {
    lastSampleTime = now;

    currentMenuState = digitalRead(nMenuPin);
    currentNextState = digitalRead(nNextPin);
    nGMT = digitalRead(nGMTPin) == LOW;
    nDST = digitalRead(nDSTPin) == LOW;

    // Menu navigation
    if (lastMenuState == LOW && currentMenuState == HIGH) {

      lastMenuItem = currentMenuItem;

      // Only update a menu item's eeprom if we are leaving that
      // menu item (e.g. gpsBaud), so that we aren't updating 
      // eeprom each time we step thru each, say, the gpsBaud choice.
      if (lastMenuItem == 1) {
        EEPROM.update(EEPROM_ADDR_ZONE, (uint8_t)Zone);
        Serial.println("  Zone EEPROM updated");
      }
      if (lastMenuItem == 2) {  // only update eeprom Brightness
        // if it was changed WITHIN the brightness menu, not
        // if it was changed due to automatic brightness adjust
        if (brightnessChanged == true) {
          brightnessChanged = false;
          EEPROM.update(EEPROM_ADDR_BRIGHTNESS, Brightness);
          Serial.println("  Brightness Level EEPROM updated");
        }
      }
      if (lastMenuItem == 3) {
        EEPROM.update(EEPROM_ADDR_HOUR24, Hour24 ? 1 : 0);
        Serial.println("  Hour24 EEPROM updated");
      }
      if (lastMenuItem == 4) {
        EEPROM.update(EEPROM_ADDR_BLINK, blink ? 1 : 0);
        Serial.println("  Blink Enable EEPROM updated");
      }
      if (lastMenuItem == 5) {
        writeLongToEEPROM(EEPROM_ADDR_GPSBAUD, gpsBaud);
        Serial.println("  GPS Baud EEPROM updated");
      }
      if (lastMenuItem == 7) {   
        EEPROM.update(EEPROM_ADDR_AMBIENT, ambient ? 1 : 0);
        Serial.println("  Ambient Enable EEPROM updated");
      }

      currentMenuItem++; // step to next menu.

      if (currentMenuItem >= numMenuItems) currentMenuItem = 0;
      Serial.print("Menu changed to: "); Serial.println(currentMenuItem);
    }

    // Menu actions -- step thru the selections in a menu
    // Note that menu items for 0 and 6 have no actions -- they simply
    // display gps info (time and satellites-tracked, respectively)
    if (lastNextState == LOW && currentNextState == HIGH) {
      switch (currentMenuItem) {
        case 1: // Zone
          Zone--;
          if (Zone < -23) Zone = 0;
          Serial.print("Zone = "); Serial.println(Zone);
          break;
        case 2: // Brightness
          Brightness--;
          brightnessChanged = true;  // brightness changed within menu.
          if (Brightness < minBrightness) Brightness = maxBrightness;      
          Serial.print("Brightness = "); Serial.println(Brightness);
          break;
        case 3: // Hour24
          Hour24 = !Hour24;
          Serial.print("Hour24 = "); Serial.println(Hour24 ? "24h" : "12h");
          break;
        case 4: // Blink
          blink = !blink;
          Serial.print("Blink = "); Serial.println(blink ? "ON" : "OFF");
          break;
        case 5: // GPS Baud
          switch (gpsBaud) {
            case 9600:   gpsBaud = 19200; break;
            case 19200:  gpsBaud = 38400; break;
            case 38400:  gpsBaud = 57600; break;
            case 57600:  gpsBaud = 115200; break;
            default:     gpsBaud = 9600; break;
          }
          gpsSerial.begin(gpsBaud);
          Serial.print("gpsBaud = "); Serial.println(gpsBaud);
          break;
        case 7: // Ambient Light Detector Enable
          ambient = !ambient;
          Serial.print("Ambient Detector = "); Serial.println(ambient ? "ON" : "OFF");
          break;        

        default: break;
      }
      
    }

    lastMenuState = currentMenuState;
    lastNextState = currentNextState;
  }

  // ---------------- GPS read and display update every 1 sec ----------------
  while(gpsSerial.available() > 0) gps.encode(gpsSerial.read());

  if(now - lastGpsSample >= gpsSampleInterval){
    lastGpsSample = now;

    if(gps.time.isValid()) { 
      gpsHour   = gps.time.hour();
      gpsMinute = gps.time.minute();
      gpsSecond = gps.time.second();

      // Time Zone, etc. calculation
      if(nGMT){ delayedHour = gpsHour; }
      else {
        delayedHour = gpsHour + Zone;
        if(nDST) delayedHour += 1;
        if(Hour24){
          if(delayedHour < 0) delayedHour += 24;
        } else {
          if(delayedHour < 0) delayedHour += 12;
          if(delayedHour > 12) delayedHour -= 12;
          if(delayedHour == 0) delayedHour = 12;
        }
      }
      GPSTime = gpsHour*100 + gpsMinute;
      if (GPSTime != 0) receivingTime = true; // GPSTime will start out = 0 at powerup.
                                              // this flag, when false,  lets us display
                                              // dashes if not getting valid time.

      Time = delayedHour * 100 + gpsMinute;
    }

    // Get number of satellites tracked
    if (gps.satellites.isValid()) {
      sats = gps.satellites.value();     // note that this should be the 8th field of $GPGGA
      #ifdef VERBOSE_SERIAL 
        Serial.print("Satellites tracked: ");
        Serial.println(sats);
      #endif
    } else {
      #ifdef VERBOSE_SERIAL
        Serial.println("Satellite data not available.");
      #endif
    }

    // Adjust Display Brightness for ambient lighting if NOT in the 
    // Brightness Menu and if "ambient" is True.
    // First read analog voltage (0-1023) 
    rawAnalog = analogRead(analogPin); 
    if ((currentMenuItem != 2) && (ambient == true)) { 
      switch(Brightness) {
        case 3:
          if (rawAnalog < (hiBright-hyst)) {
            Brightness = 2;
            display.setBrightness(Brightness);
            Serial.print("  New brightness: "); Serial.println(Brightness);
          }
          break;

        case 2:
          if (rawAnalog > (hiBright + hyst)) {
            Brightness = 3;
            display.setBrightness(Brightness);
            Serial.print("  New brightness: "); Serial.println(Brightness);
          }
          else if (rawAnalog < (midBright - hyst)) {
            Brightness = 1;
            display.setBrightness(Brightness);
            Serial.print("  New brightness: "); Serial.println(Brightness);
          }
          break;

        case 1:
          if (rawAnalog > (midBright + hyst)) {
            Brightness = 2;
            display.setBrightness(Brightness);
            Serial.print("  New brightness: "); Serial.println(Brightness);
          }
          else if (rawAnalog < (lowBright - hyst)) {
            Brightness = 0;
            display.setBrightness(Brightness);
            Serial.print("  New brightness: "); Serial.println(Brightness);
          }
          break;

        case 0:
          if (rawAnalog > (lowBright + hyst)) {
            Brightness = 1;
            display.setBrightness(Brightness);
            Serial.print("  New brightness: "); Serial.println(Brightness);
          }
          break;
  
        default: break;

      }
    }     


    // ---------------- Display output for menus ----------------
    uint8_t segData[4] = {0,0,0,0};
    switch(currentMenuItem){
      case 0: // GPS Time
        if(gps.time.isValid() && receivingTime == true) { 
          if (Hour24 == true) {
            // Update LCD with Time and appropriate Colon state
            // do NOT suppress leading zeroes
            if(!blink == true) display.showNumberDecEx(Time, 0b01000000, true, 4, 0);
            else {
              if (colonState == false) {
                display.showNumberDecEx(Time, 0b00000000, true, 4, 0);
                colonState = !colonState;
              }
              else {
                display.showNumberDecEx(Time, 0b01000000, true, 4, 0);
                colonState = !colonState;
              }
            }
          }
          else {
            // Update LCD with Time and appropriate Colon state.
            // Suppress leading zeroes
            if(!blink == true) display.showNumberDecEx(Time, 0b01000000, false, 4, 0);
            else {
              if (colonState == false) {
                display.showNumberDecEx(Time, 0b00000000, false, 4, 0);
                colonState = !colonState;
              }
              else {
                display.showNumberDecEx(Time, 0b01000000, false, 4, 0);
                colonState = !colonState;
              }
            }
          }
          
        }
        else {
          if(receivingTime == false) display.setSegments(dash);
        }
        break;

      case 1: // Zone
        // First character is a 't' (using seven segments)
        // Then display the zone offset from GMT as a negative number,
        // WITHOUT Daily-Time adjustment (i.e. Standard Time only)
        absZone = 0;
        if (Zone != 0) absZone = -Zone;
        segData[0] = SEG_D | SEG_E | SEG_F | SEG_G; 
        segData[1] = 0x40;  // dash
        segData[2] = display.encodeDigit(absZone / 10);
        segData[3] = display.encodeDigit(absZone % 10);
        display.setSegments(segData);
        break;

      case 2: // Brightness
        // Display TM1637 display brightness value.
        // First two characters are "br", followed by colon
        // then brightness value.
        display.setBrightness(Brightness);

        segData[0] = SEG_C | SEG_D | SEG_E | SEG_F | SEG_G; // d,e,f,g + c
        segData[1] = SEG_E | SEG_G | 0x80; // e+g, plus colon
        segData[2] = display.encodeDigit(Brightness / 10);
        segData[3] = display.encodeDigit(Brightness % 10);
        display.setSegments(segData);
        break;

      case 3: // Hour24
        // First two characters are "Hr" followed by the colon.
        // last two characters are either 24 or 12.
        segData[0] = SEG_C | SEG_B | SEG_E | SEG_F | SEG_G; // b,c,e,f,g
        segData[1] = SEG_E | SEG_G | 0x80; // e,g plus colon
        segData[2] = display.encodeDigit(Hour24 ? 2 : 1);
        segData[3] = display.encodeDigit(Hour24 ? 4 : 2);
        display.setSegments(segData);
        break;

      case 4: // Blink
        // First two characters are "bL" followed by the colon.
        // last two characters are either "On" for ON or "Of" for OFF
        segData[0] = SEG_C | SEG_D | SEG_E | SEG_F | SEG_G; // c,d,e,f,g
        segData[1] = SEG_E | SEG_D | SEG_F | 0x80; // d,e,f plus colon
        if(blink){
          segData[2] = SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F; // a,b,c,d,e,f
          segData[3] = SEG_E | SEG_C | SEG_G; // c,e,g
        } else {
          segData[2] = SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F; // a,b,c,d,e,f
          segData[3] = SEG_A | SEG_G | SEG_E | SEG_F; // a,e,f,g
        }
        display.setSegments(segData);
        break;

      case 5: // GPS Baud   
        // Displays gps baud rate / 100.
        baudDisplay = gpsBaud / 100;
        display.showNumberDecEx(baudDisplay, 0x00, false, 4, 0);
        break;

      case 6:  
        // Displays the number of satellites tracked.
        // first characters are "SA" plus the colon
        // The second two characters are the number of satellites tracked
        // (from the eighth field of the $GPGGA message).
        // If no satellite data is available, a "-" is shown.
          segData[0] = SEG_A | SEG_F | SEG_G | SEG_C | SEG_D;        // S
          segData[1] = SEG_A|SEG_B|SEG_C|SEG_E|SEG_F|SEG_G | 0x80;   // A, plus colon
        if (gps.satellites.isValid()) {
          if (sats < 10) segData[2] = 0;   // blank first digit if 0
          else segData[2] = display.encodeDigit(sats / 10);
          segData[3] = display.encodeDigit(sats % 10);
          }
        else {
          segData[2] = 0;
          segData[3] = SEG_G;   // dash
        }
        display.setSegments(segData);  
        break;

      case 7:  // First two characters are "AL" followed by the colon.
        // last two characters are either "On" for ON or "Of" for OFF
        segData[0] = SEG_A | SEG_B | SEG_C | SEG_E | SEG_F | SEG_G; // A
        segData[1] = SEG_E | SEG_D | SEG_F | 0x80; // L plus colon
        if(ambient){
          segData[2] = SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F; // a,b,c,d,e,f
          segData[3] = SEG_E | SEG_C | SEG_G; // c,e,g
        } else {
          segData[2] = SEG_A | SEG_B | SEG_C | SEG_D | SEG_E | SEG_F; // a,b,c,d,e,f
          segData[3] = SEG_A | SEG_G | SEG_E | SEG_F; // a,e,f,g
        }
        display.setSegments(segData);
        break;


      case 8:
        // display the raw analog value (referenced to 5V, 1023 max) on
        // the defined analog pin.    
        display.showNumberDecEx(rawAnalog);
        break;

      default: break;
    }

    #ifdef VERBOSE_SERIAL
      // Serial output
      Serial.print("GPS Time: "); Serial.print(gpsHour); Serial.print(":");
      Serial.print(gpsMinute); Serial.print(":"); Serial.println(gpsSecond);
      //Serial.print("Delayed Hour: "); Serial.print(delayedHour); Serial.print(" | Time (HHMM): "); Serial.println(Time);
      Serial.print("Raw Analog "); Serial.print(": "); Serial.println(rawAnalog);     
    #endif
  }
}
